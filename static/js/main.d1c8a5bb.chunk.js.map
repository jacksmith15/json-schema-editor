{"version":3,"sources":["helpers.js","forms/properties.js","forms/type.js","forms/blank.js","Builder.js","forms/reference.js","forms/composition.js","serviceWorker.js","index.js"],"names":["xSet","other","Set","this","filter","x","has","filterProps","obj","newObject","prop","merge","objects","Object","assign","Path","object","defaultValue","length","getOne","key","returnValue","segments","reduce","_err","value","cloneDeep","target","slice","segment","split","Boolean","args","join","String","PropertyEditor","props","React","useState","propertyName","setPropertyName","selectedProperty","setSelectedProperty","propertySchemas","path","get","schema","properties","propertyFields","property","push","PropertyField","setSchemaValue","delSchemaValue","onClick","Fragment","Accordion","activeKey","class","Form","Group","onChange","event","className","InputGroup","Control","type","placeholder","Append","Button","subSchema","required","Card","Toggle","as","Header","variant","eventKey","Container","Row","Col","ButtonGroup","toggle","style","float","ToggleButton","checked","includes","isRequired","newRequired","item","setRequired","newSubSchema","remove","removeProperty","Collapse","Body","SchemaForm","KEYWORDS","array","minItems","name","default","maxItems","uniqueItems","boolean","integer","minimum","maximum","exclusiveMaximum","exclusiveMinimum","multipleOf","number","null","additionalProperties","minProperties","maxProperties","string","format","pattern","minLength","maxLength","ValidationSelector","keywordConfig","keyword","keys","values","typeName","DropdownButton","id","title","drop","entries","map","entry","Dropdown","Item","ValidationInputs","presentKeywords","inputs","ValidationInput","keywordSpec","keywordType","parseFloat","getParser","Label","defaultChecked","LaunchSchemaModal","AcceptButton","isRoot","stagedSchemaName","setStagedSchemaName","handleAccept","disabled","readyToAccept","Modal","show","size","aria-labelledby","onHide","setShow","centered","closeButton","Title","Tabs","tab","onSelect","setTab","Tab","setChoices","choices","reference","ReferenceTab","multiple","call","selectedOptions","opt","TypeTab","composition","CompositionTab","Footer","METATYPE","referenceName","types","schemaName","index","Badge","block","setSchemaName","COMPOSITION_KEYWORDS","Builder","setSchema","set","SchemaRenderer","JSON","stringify","FormComponent","intersection","getSchemaFormComponent","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.d1c8a5bb.chunk.js","sourcesContent":["import { cloneDeep, isEqual } from \"lodash\";\n\n/**\n * Remove object keys with null of empty values.\n */\nfunction clean(object) {\n    if (typeof object !== \"object\" || object === null) {\n        return object;\n    }\n    if (Array.isArray(object)) {\n        let newArray = [];\n        for (let val of object) {\n            newArray.push(clean(val));\n        }\n        return newArray;\n    }\n    // The following should handle both arrays and objects.\n    let newObject = {};\n    for (const key in object) {\n        let val = clean(object[key]);\n        if (isEqual(val, {}) || val === null || isEqual(val, [])) {\n            continue;\n        }\n        newObject[key] = val;\n    }\n    return newObject;\n}\n\n/**\n * Extended set with common binary set operations as instance methods.\n */\nclass xSet extends Set {\n    union(other) {\n        return new Set([...this, ...other]);\n    }\n\n    intersection(other) {\n        return new Set([...this].filter((x) => other.has(x)));\n    }\n\n    difference(other) {\n        return new Set([...this].filter((x) => !other.has(x)));\n    }\n}\n\n\n/**\n * Return an object with properties filtered.\n */\nfunction filterProps(filter, obj) {\n    let newObject = {};\n    for (const prop in obj) {\n        if (filter(prop)) {\n            newObject[prop] = obj[prop];\n        }\n    }\n    return newObject;\n}\n\n\n/**\n * Return a new object, which merges the supplied ones.\n *\n * When called with one object this acts as a copy.\n */\nfunction merge(...objects) {\n    return Object.assign({}, ...objects);\n}\n\n/**\n * Dotted path object with helper methods.\n */\nclass Path extends String {\n    static join(...args) {\n        return new Path(args.filter(Boolean).join(\".\"));\n    }\n\n    get segments() {\n        return this.split(\".\").filter(Boolean);\n    }\n\n    get depth() {\n        return this.segments.length;\n    }\n\n    get(object, defaultValue = null) {\n        if (!this.length) {\n            return object;\n        }\n        try {\n            const getOne = (obj, key) => obj[key];\n            const returnValue = this.segments.reduce(getOne, object);\n            if (typeof returnValue === \"undefined\") {\n                return defaultValue;\n            }\n            return returnValue;\n        } catch (_err) {\n            return defaultValue;\n        }\n    }\n\n    set(object, value) {\n        let newObject = cloneDeep(object);\n        let target = newObject;\n        if (!this.length) {\n            return value;\n        }\n        for (let segment of this.segments.slice(0, -1)) {\n            if (!(segment in target)) {\n                target[segment] = {};\n            }\n            target = target[segment];\n        }\n        target[this.segments.slice(-1)[0]] = value;\n        return newObject;\n    }\n\n    remove(object) {\n        let newObject = cloneDeep(object);\n        let target = newObject;\n        if (!this.length) {\n            return undefined;\n        }\n        for (let segment of this.segments.slice(0, -1)) {\n            if (!(segment in target)) {\n                return newObject;\n            }\n            target = target[segment];\n        }\n        delete target[this.segments.slice(-1)[0]]\n        return newObject;\n    }\n}\n\nexport { Path, merge, filterProps, xSet, clean };\n","import React from \"react\";\nimport {\n    Accordion,\n    Button,\n    ButtonGroup,\n    Card,\n    Col,\n    Container,\n    Form,\n    InputGroup,\n    Row,\n    ToggleButton,\n} from \"react-bootstrap\";\n\nimport { Path } from \"helpers\";\nimport { SchemaForm } from \"Builder\";\n\nfunction PropertyEditor(props) {\n    const [propertyName, setPropertyName] = React.useState(\"\");\n    const [selectedProperty, setSelectedProperty] = React.useState(null);\n\n    const subSchema = new Path(props.path).get(props.schema);\n\n    const propertySchemas = subSchema.properties;\n    let propertyFields = [];\n    for (const property in propertySchemas) {\n        propertyFields.push(\n            <PropertyField\n                key={property}\n                property={property}\n                setSchemaValue={props.setSchemaValue}\n                delSchemaValue={props.delSchemaValue}\n                schema={props.schema}\n                path={props.path}\n                onClick={() => {\n                    selectedProperty !== property\n                        ? setSelectedProperty(property)\n                        : setSelectedProperty(null);\n                }}\n            />\n        );\n    }\n    return (\n        <React.Fragment>\n            <h4>Properties</h4>\n            <Accordion activeKey={selectedProperty}>{propertyFields}</Accordion>\n            <div class=\"mt-3\" />\n            <Form.Group\n                onChange={(event) => setPropertyName(event.target.value)}\n                className=\"form-inline\"\n            >\n                <InputGroup>\n                    <Form.Control\n                        type=\"text\"\n                        placeholder=\"Enter property name here...\"\n                        value={propertyName}\n                    />\n                    <InputGroup.Append>\n                        <Button\n                            onClick={() => {\n                                if (propertyName.length) {\n                                    props.setSchemaValue(\n                                        Path.join(\n                                            props.path,\n                                            \"properties\",\n                                            propertyName\n                                        ),\n                                        {}\n                                    );\n                                }\n                                setPropertyName(\"\");\n                            }}\n                        >\n                            Add property\n                        </Button>\n                    </InputGroup.Append>\n                </InputGroup>\n            </Form.Group>\n        </React.Fragment>\n    );\n}\n\nfunction PropertyField(props) {\n    const property = props.property;\n    const subSchema = new Path(props.path).get(props.schema);\n    const required = subSchema.required || [];\n\n    const setRequired = (isRequired) => {\n        let newRequired = [];\n        if (isRequired) {\n            newRequired = [...required, property];\n        } else {\n            newRequired = required.filter((item) => item !== property);\n        }\n        if (!newRequired.length) {\n            props.delSchemaValue(Path.join(props.path, \"required\"));\n        } else {\n            props.setSchemaValue(\n                Path.join(props.path, \"required\"),\n                newRequired\n            );\n        }\n    };\n    const removeProperty = () => {\n        let newSubSchema = Path.join(props.path, \"properties\", property).remove(\n            subSchema\n        );\n        let newRequired = required.filter((item) => item !== property);\n        if (newRequired.length) {\n            newSubSchema.required = newRequired;\n        } else {\n            delete newSubSchema.required;\n        }\n        props.setSchemaValue(props.path, newSubSchema);\n    };\n\n    return (\n        <Card>\n            <Accordion.Toggle\n                as={Card.Header}\n                variant=\"link\"\n                eventKey={property}\n                onClick={props.onClick}\n            >\n                <Container>\n                    <Row>\n                        <Col>\n                            <h5>\n                                <i>{property}</i>\n                            </h5>\n                        </Col>\n                        <Col>\n                            <ButtonGroup toggle style={{ float: \"right\" }}>\n                                <ToggleButton\n                                    type=\"checkbox\"\n                                    checked={required.includes(property)}\n                                    onChange={(event) =>\n                                        setRequired(event.target.checked)\n                                    }\n                                    variant={\n                                        required.includes(property)\n                                            ? \"primary\"\n                                            : \"secondary\"\n                                    }\n                                >\n                                    Required\n                                </ToggleButton>\n                                <Button\n                                    variant=\"danger\"\n                                    onClick={(event) => removeProperty()}\n                                >\n                                    Remove\n                                </Button>\n                            </ButtonGroup>\n                        </Col>\n                    </Row>\n                </Container>\n            </Accordion.Toggle>\n            <Accordion.Collapse eventKey={property}>\n                <Card.Body>\n                    <SchemaForm\n                        setSchemaValue={props.setSchemaValue}\n                        delSchemaValue={props.delSchemaValue}\n                        schema={props.schema}\n                        path={Path.join(props.path, \"properties\", property)}\n                    />\n                </Card.Body>\n            </Accordion.Collapse>\n        </Card>\n    );\n}\n\nexport { PropertyEditor };\n","import React from \"react\";\nimport {\n    Badge,\n    Button,\n    Dropdown,\n    DropdownButton,\n    Form,\n    InputGroup,\n} from \"react-bootstrap\";\n\nimport { filterProps, merge, Path } from \"helpers\";\nimport {PropertyEditor } from \"forms/properties\";\n\nconst KEYWORDS = {\n    array: {\n        minItems: { name: \"Minimum items\", type: \"number\", default: 0 },\n        maxItems: { name: \"Maximum items\", type: \"number\", default: 10 },\n        uniqueItems: { name: \"Unique items\", type: \"checkbox\", default: true },\n    },\n    boolean: {},\n    integer: {\n        minimum: { name: \"Minimum value\", type: \"number\", default: 0 },\n        maximum: { name: \"Maximum value\", type: \"number\", default: 100 },\n        exclusiveMaximum: {\n            name: \"Exclusive maximum\",\n            type: \"number\",\n            default: 100,\n        },\n        exclusiveMinimum: {\n            name: \"Exclusive minimum\",\n            type: \"number\",\n            default: 0,\n        },\n        multipleOf: { name: \"Multiple of\", type: \"number\", default: 2 },\n    },\n    number: {\n        minimum: { name: \"Minimum value\", type: \"number\", default: 0.0 },\n        maximum: { name: \"Maximum value\", type: \"number\", default: 10.0 },\n        exclusiveMaximum: {\n            name: \"Exclusive maximum\",\n            type: \"number\",\n            default: 10.0,\n        },\n        exclusiveMinimum: {\n            name: \"Exclusive minimum\",\n            type: \"number\",\n            default: 0.0,\n        },\n        multipleOf: { name: \"Multiple of\", type: \"number\", default: 2.0 },\n    },\n    null: {},\n    object: {\n        additionalProperties: {\n            name: \"Additional properties\",\n            type: \"checkbox\",\n            default: false,\n        },\n        minProperties: {\n            name: \"Minimum properties\",\n            type: \"number\",\n            default: 0,\n        },\n        maxProperties: {\n            name: \"Maximum properties\",\n            type: \"number\",\n            default: 10,\n        },\n    },\n    string: {\n        format: { name: \"Format\", type: \"text\", default: \"\" },\n        pattern: { name: \"Pattern\", type: \"text\", default: \"\" },\n        minLength: { name: \"Minimum length\", type: \"number\", default: 3 },\n        maxLength: { name: \"Maximum length\", type: \"number\", default: 200 },\n    },\n};\n\n\n/**\n * Get JSON parser for form input.\n */\nfunction getParser(keyword) {\n    const keywordConf = Object.assign({}, ...Object.values(KEYWORDS));\n    const keywordType = keywordConf[keyword].type;\n    function parser(value) {\n        if (keywordType === \"number\") {\n            return parseFloat(value);\n        }\n        return value;\n    }\n    return parser;\n}\n\n\nfunction TypeForm(props) {\n    const subSchema = new Path(props.path).get(props.schema);\n    const types = subSchema.type;\n    return (\n        <React.Fragment>\n            <h3>\n                {props.schemaName}{types.map((value, index) => (\n                    <React.Fragment key={index}>\n                        {\" \"}\n                        <Badge variant=\"secondary\">{value}</Badge>{\" \"}\n                    </React.Fragment>\n                ))}\n            </h3>\n            <h4>Validation rules</h4>\n            <ValidationSelector\n                path={props.path}\n                schema={props.schema}\n                setSchemaValue={props.setSchemaValue}\n            />\n            <ValidationInputs\n                setSchemaValue={props.setSchemaValue}\n                delSchemaValue={props.delSchemaValue}\n                schema={props.schema}\n                path={props.path}\n            />\n            {types.includes(\"object\") ? (\n                <PropertyEditor\n                    path={props.path}\n                    schema={props.schema}\n                    setSchemaValue={props.setSchemaValue}\n                    delSchemaValue={props.delSchemaValue}\n                />\n            ) : (\n                \"\"\n            )}\n        </React.Fragment>\n    );\n}\n\nfunction ValidationSelector(props) {\n    const subSchema = new Path(props.path).get(props.schema);\n    const keywordConfig = filterProps(\n        (keyword) => !Object.keys(subSchema).includes(keyword),\n        merge(\n            {},\n            ...Object.values(\n                filterProps((typeName) => subSchema.type.includes(typeName), KEYWORDS)\n            )\n        )\n    );\n    if (Object.keys(keywordConfig).length) {\n        return (\n            <Form.Group>\n                <DropdownButton\n                    id={props.path + \".add-validation\"}\n                    title=\"Add validation rule...\"\n                    drop=\"right\"\n                >\n                    {Object.entries(keywordConfig).map((entry) => (\n                        <Dropdown.Item\n                            as=\"button\"\n                            onClick={() => {\n                                props.setSchemaValue(\n                                    Path.join(props.path, entry[0]),\n                                    subSchema[entry[0]] || entry[1].default\n                                );\n                            }}\n                        >\n                            {entry[1].name}\n                        </Dropdown.Item>\n                    ))}\n                </DropdownButton>\n            </Form.Group>\n        );\n    }\n    return null;\n}\n\n\nfunction ValidationInputs(props) {\n    const subSchema = new Path(props.path).get(props.schema);\n    const keywordSpecs = merge({}, ...Object.values(KEYWORDS));\n    const presentKeywords = filterProps(\n        (key) => Object.keys(subSchema).includes(key),\n        keywordSpecs\n    );\n    let inputs = [];\n    for (const keyword of Object.keys(presentKeywords)) {\n        inputs.push(\n            <ValidationInput\n                path={props.path}\n                schema={props.schema}\n                setSchemaValue={props.setSchemaValue}\n                delSchemaValue={props.delSchemaValue}\n                keyword={keyword}\n            />\n        );\n    }\n    return <React.Fragment>{inputs}</React.Fragment>;\n}\n\nfunction ValidationInput(props) {\n    const subSchema = new Path(props.path).get(props.schema);\n    const keywordSpec = merge({}, ...Object.values(KEYWORDS))[props.keyword];\n    return (\n        <Form.Group\n            name={props.keyword}\n            key={props.keyword}\n            onChange={(event) => {\n                const value =\n                    event.target.type === \"checkbox\"\n                        ? event.target.checked\n                        : event.target.value;\n                props.setSchemaValue(\n                    Path.join(props.path, props.keyword),\n                    getParser(props.keyword)(value)\n                );\n            }}\n        >\n            <Form.Label>{keywordSpec.name}</Form.Label>\n            <InputGroup>\n                <Form.Control\n                    type={keywordSpec.type}\n                    defaultValue={subSchema[props.keyword]}\n                    defaultChecked={keywordSpec.default === true}\n                ></Form.Control>\n                <InputGroup.Append>\n                    <Button\n                        variant=\"danger\"\n                        onClick={() =>\n                            props.delSchemaValue(\n                                Path.join(props.path, props.keyword),\n                            )\n                        }\n                    >\n                        Remove\n                    </Button>\n                </InputGroup.Append>\n            </InputGroup>\n        </Form.Group>\n    );\n}\n\n\nexport { TypeForm };\n","import React from \"react\";\nimport {\n    Button,\n    Container,\n    Form,\n    InputGroup,\n    Modal,\n    Navbar,\n    Tab,\n    Tabs,\n} from \"react-bootstrap\";\n\nimport { merge, Path } from \"helpers\";\n\n\nfunction BlankForm(props) {\n    const isRoot = !props.path.length;\n    const [show, setShow] = React.useState(false);\n    const [tab, setTab] = React.useState(isRoot ? \"type\" : \"reference\");\n    const [choices, setChoices] = React.useState({\n        reference: null,\n        type: [],\n        composition: null,\n    });\n    const [stagedSchemaName, setStagedSchemaName] = React.useState(\n        props.schemaName\n    );\n    const readyToAccept =\n        (!isRoot || stagedSchemaName.length > 0) &&\n        ((tab === \"composition\" && choices.composition !== null) ||\n            (tab === \"reference\" && choices.reference !== null) ||\n            (tab === \"type\" && choices.type.length > 0));\n    const handleAccept = () => {\n        if (isRoot) {\n            props.setSchemaName(stagedSchemaName);\n        }\n        if (tab === \"composition\" && choices.composition !== null) {\n            props.setSchemaValue(\n                Path.join(props.path, choices[tab]),\n                choices[tab] === \"not\" ? {} : []\n            );\n        } else if (tab === \"reference\" && choices.reference !== null) {\n            props.setSchemaValue(\n                Path.join(props.path, \"$ref\"),\n                `#/definitions/${choices[tab]}`\n            );\n        } else if (tab === \"type\" && choices[tab].length) {\n            props.setSchemaValue(Path.join(props.path, \"type\"), choices[tab]);\n        }\n        setShow(false);\n    };\n    const handleShow = () => setShow(true);\n\n    return (\n        <Form.Group>\n            <Button onClick={handleShow} block>\n                Create schema\n            </Button>\n\n            <LaunchSchemaModal\n                show={show}\n                setShow={setShow}\n                handleAccept={handleAccept}\n                tab={tab}\n                setTab={setTab}\n                choices={choices}\n                setChoices={setChoices}\n                stagedSchemaName={stagedSchemaName}\n                setStagedSchemaName={setStagedSchemaName}\n                isRoot={isRoot}\n                readyToAccept={readyToAccept}\n            />\n        </Form.Group>\n    );\n}\n\nfunction LaunchSchemaModal(props) {\n    let AcceptButton = null;\n    if (props.isRoot) {\n        AcceptButton = (\n            <Form.Group>\n                <InputGroup>\n                    <Form.Control\n                        type=\"text\"\n                        placeholder=\"Enter schema name here...\"\n                        value={props.stagedSchemaName}\n                        onChange={(event) =>\n                            props.setStagedSchemaName(event.target.value)\n                        }\n                    />\n                    <InputGroup.Append>\n                        <Button\n                            onClick={props.handleAccept}\n                            disabled={!props.readyToAccept}\n                        >\n                            Accept\n                        </Button>\n                    </InputGroup.Append>\n                </InputGroup>\n            </Form.Group>\n        );\n    } else {\n        AcceptButton = (\n            <Button onClick={props.handleAccept} disabled={!props.readyToAccept}>\n                Accept\n            </Button>\n        );\n    }\n    return (\n        <Modal\n            show={props.show}\n            size=\"lg\"\n            aria-labelledby=\"contained-modal-title-vcenter\"\n            onHide={() => {props.setShow(false);}}\n            centered\n        >\n            <Modal.Header closeButton>\n                <Modal.Title id=\"contained-modal-title-vcenter\">\n                    Create schema\n                </Modal.Title>\n            </Modal.Header>\n            <Modal.Body>\n                <Tabs\n                    activeKey={props.tab}\n                    onSelect={(key) => props.setTab(key)}\n                >\n                    {ReferenceTab({\n                        choices: props.choices,\n                        setChoices: props.setChoices,\n                    })}\n                    {TypeTab({\n                        choices: props.choices,\n                        setChoices: props.setChoices,\n                    })}\n                    {CompositionTab({\n                        choices: props.choices,\n                        setChoices: props.setChoices,\n                    })}\n                </Tabs>\n            </Modal.Body>\n            <Modal.Footer>{AcceptButton}</Modal.Footer>\n        </Modal>\n    );\n}\n\nfunction ReferenceTab(props) {\n    return (\n        <Tab eventKey=\"reference\" title=\"Choose reference\">\n            <div class=\"mt-3\" />\n            <Form.Group className=\"my-2\">\n                <Form.Control\n                    as=\"select\"\n                    onChange={(event) =>\n                        props.setChoices(\n                            merge(props.choices, {\n                                reference: event.target.value,\n                            })\n                        )\n                    }\n                    defaultValue=\"\"\n                >\n                    {/* These options should be pulled from a store. */}\n                    <option value=\"\" disabled>\n                        Select one..\n                    </option>\n                    <option value=\"uuid\">UUID</option>\n                    <option value=\"even-number\">Even Number</option>\n                </Form.Control>\n            </Form.Group>\n        </Tab>\n    );\n}\n\nfunction TypeTab(props) {\n    return (\n        <Tab eventKey=\"type\" title=\"Create new\">\n            <div class=\"mt-3\" />\n            <Form.Group className=\"my-2\">\n                <Form.Control\n                    as=\"select\"\n                    multiple\n                    onChange={(event) =>\n                        props.setChoices(\n                            merge(props.choices, {\n                                type: [].slice\n                                    .call(event.target.selectedOptions)\n                                    .map((opt) => opt.value),\n                            })\n                        )\n                    }\n                    value={props.choices.type}\n                >\n                    <option value=\"array\">Array</option>\n                    <option value=\"boolean\">Boolean</option>\n                    <option value=\"integer\">Integer</option>\n                    <option value=\"null\">Null</option>\n                    <option value=\"number\">Number</option>\n                    <option value=\"object\">Object</option>\n                    <option value=\"string\">String</option>\n                </Form.Control>\n            </Form.Group>\n        </Tab>\n    );\n}\n\nfunction CompositionTab(props) {\n    return (\n        <Tab eventKey=\"composition\" title=\"Compose\">\n            <div class=\"mt-3\" />\n            <Form.Group className=\"my-2\">\n                <Form.Control\n                    as=\"select\"\n                    onChange={(event) =>\n                        props.setChoices(\n                            merge(props.choices, {\n                                composition: event.target.value,\n                            })\n                        )\n                    }\n                    defaultValue=\"\"\n                >\n                    <option value=\"\" disabled>\n                        Select one..\n                    </option>\n                    <option value=\"anyOf\">Match Any</option>\n                    <option value=\"allOf\">Match All</option>\n                    <option value=\"oneOf\">Match One</option>\n                    <option value=\"not\">Not</option>\n                </Form.Control>\n            </Form.Group>\n        </Tab>\n    );\n}\n\nexport { BlankForm };\n","import React from \"react\";\nimport styled from \"styled-components\";\nimport {\n    Accordion,\n    Card,\n    Container,\n    Form,\n    Button,\n    Modal,\n    Navbar,\n    Row,\n    Tabs,\n    Tab,\n} from \"react-bootstrap\";\nimport { Path, xSet, clean } from \"helpers\";\nimport { TypeForm } from \"forms/type\";\nimport { BlankForm } from \"forms/blank\";\nimport { ReferenceForm } from \"forms/reference\";\nimport { CompositionForm } from \"forms/composition\";\n\n// TODO: Spacing\n// TODO: Save and reference schemas\n// TODO: Pass minimal state\n// TODO: Make boolean val keywords Add/Remove only\n// TODO: Stage and commit schema changes\n// TODO: Make the card headers for properties look nice\n\nconst METATYPE = {\n    reference: ReferenceForm,\n    type: TypeForm,\n    composition: CompositionForm,\n    blank: BlankForm,\n};\n\nconst COMPOSITION_KEYWORDS = new xSet([\"allOf\", \"anyOf\", \"oneOf\", \"not\"]);\n\nfunction Builder(props) {\n    const [schema, setSchema] = React.useState({});\n    const [schemaName, setSchemaName] = React.useState(\"\");\n\n    const setSchemaValue = (path, value) =>\n        setSchema(new Path(path).set(schema, value));\n\n    const delSchemaValue = (path) => setSchema(new Path(path).remove(schema));\n\n    return (\n        <Container>\n            <Row>\n                <SchemaForm\n                    setSchemaValue={setSchemaValue}\n                    delSchemaValue={delSchemaValue}\n                    schema={schema}\n                    path=\"\"\n                    setSchemaName={setSchemaName}\n                    schemaName={schemaName}\n                />\n            </Row>\n            <Row>\n                <SchemaRenderer schema={schema} />\n            </Row>\n        </Container>\n    );\n}\n\nfunction SchemaRenderer(props) {\n    return (\n        <Container>\n            <Accordion>\n                <Card>\n                    <Accordion.Toggle\n                        as={Card.Header}\n                        variant=\"link\"\n                        eventKey=\"preview\"\n                    >\n                        Preview\n                    </Accordion.Toggle>\n                    <Accordion.Collapse eventKey=\"preview\">\n                        <pre>{JSON.stringify(props.schema, null, 2)}</pre>\n                    </Accordion.Collapse>\n                </Card>\n            </Accordion>\n        </Container>\n    );\n}\n\nfunction SchemaForm(props) {\n    const schema = new Path(props.path).get(props.schema);\n    const FormComponent = getSchemaFormComponent(schema);\n    return (\n        <Container>\n            <FormComponent\n                setSchemaValue={props.setSchemaValue}\n                delSchemaValue={props.delSchemaValue}\n                schema={props.schema}\n                path={props.path}\n                setSchemaName={props.setSchemaName}\n                schemaName={props.schemaName}\n            />\n        </Container>\n    );\n}\n\nfunction getSchemaFormComponent(schema) {\n    if (\"$ref\" in schema) {\n        return METATYPE.reference;\n    } else if (new xSet(schema.keys).intersection(COMPOSITION_KEYWORDS).size) {\n        return METATYPE.composition;\n    } else if (Object.keys(schema).includes(\"type\")) {\n        return METATYPE.type;\n    } else {\n        return METATYPE.blank;\n    }\n}\n\nexport { Builder, SchemaForm };\n","import React from \"react\";\nimport {\n    Button,\n} from \"react-bootstrap\";\n\nimport { Path } from \"helpers\";\n\nfunction ReferenceForm(props) {\n    const subSchema = new Path(props.path).get(props.schema);\n    const referenceName = subSchema[\"$ref\"].split(\"/\").slice(-1)[0];\n    return <Button variant=\"info\" disabled>{referenceName}</Button>;\n}\n\nexport { ReferenceForm };\n","import React from \"react\";\nimport { Path } from \"helpers\";\n\nfunction CompositionForm(props) {\n    // const subSchema = new Path(props.path).get(props.schema);\n    return <div>Not implemented</div>;\n}\n\nexport { CompositionForm };\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n// import './index.css';\n// import App from './App';\nimport {Builder} from './Builder';\nimport 'Builder.css'\nimport * as serviceWorker from './serviceWorker';\nimport 'bootstrap/dist/css/bootstrap.min.css';\n\nReactDOM.render(\n  <React.StrictMode>\n    <Builder />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}